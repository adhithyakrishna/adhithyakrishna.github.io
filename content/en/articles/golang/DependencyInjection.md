---
title: "Dependency injection in golang"
description : "An article about dependency injection in golang"
date: 2021-02-01T16:25:16-05:00
draft: false
---

This post was inspired by an awesome tech talk by Florian Patan at GopherCon UK in 2018 where he goes over creating a goservice in 30 minutes. The interesting take away from the talk was the use of dependency injection to insert a logger instance into the handler.

My aim for this article is to dissect dependency injection into smaller chunks to understand how it works.

The initial code for the project is given below. (main.go)
```Go
package main

import (
	"log"
	"net/http"
	"os"
)

func main() {
	logger := log.New(os.Stdout, "log ", log.LstdFlags|log.Ltime|log.Lshortfile)

	mux := http.NewServeMux()

	mux.HandleFunc("/", func(rw http.ResponseWriter, r *http.Request) {
		logger.Printf("Inside handler")
		rw.Header().Set("Content-Type", "text/plain; charset=utf-8")
		rw.WriteHeader(http.StatusOK)
		rw.Write([]byte("Hello world"))
	})

	http.ListenAndServe(":8080", mux)
}
```
Note that new instance of logger has been initialised in line 10. 
The flags **log.LstdFlags** define which text to prefix to each log entry generated by the Logger. 
**log.Ltime** represents the time at which the log was generated and the **log.Lshortfile** represents the name of the file from which the log was printed.

On executing the file we get the following output.
{{< boxmd >}}
log 2021/02/01 16:44:03 main.go:15: Inside root
log 2021/02/01 16:44:03 main.go:15: Inside root
{{< /boxmd >}}

The logger instance was generated in main.go file. Suppose we want to create a new router called home. Instead of creating a new instance of logger we can simply inject it into the router. This is where the dependency injection comes into the picture.

We create a new package that handles the logic of /home route. The new package is **home package**. In the home.go file, we add the following code.

## Dependency Injection 

#### Step 1 : Create a Handler of type struct and initialise a logger variable of the type log.Logger

```GO
type Handlers struct {
	logger *log.Logger
}
```

#### Step 2 : Create a function constructor to initialise the logger variable. It returns an address of the initialised Handler.

```GO
func NewHandlers(logger *log.Logger) *Handlers {
	return &Handlers{
		logger: logger,
	}
}
```

#### Step 3: Handle method takes implementation of http.Handler interface as the second argument, hence serveHttp method has been intialised with the code logic (logger is accesses inside the function).

```GO
func (h *Handlers) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	h.logger.Printf("Inside home")
	rw.Header().Set("Content-Type", "text/plain; charset=utf-8")
	rw.WriteHeader(http.StatusOK)
	rw.Write([]byte("from home page"))
}
```

#### Step 4: Instance of handler is intialised and assigned to a new variable passed to the /home router

```GO
func main() {
	logger := log.New(os.Stdout, "log ", log.LstdFlags|log.Ltime|log.Lshortfile)

	h := homePage.NewHandlers(logger)

	mux := http.NewServeMux()

	mux.HandleFunc("/", func(rw http.ResponseWriter, r *http.Request) {
		logger.Printf("Inside root")
		rw.Header().Set("Content-Type", "text/plain; charset=utf-8")
		rw.WriteHeader(http.StatusOK)
		rw.Write([]byte("Hello world"))
	})

	mux.Handle("/home", h)
	http.ListenAndServe(":8080", mux)
}
```

The output is 
{{< boxmd >}}
log 2021/02/01 18:48:55 main.go:18: Inside handler
log 2021/02/01 18:49:04 home.go:19: Inside home
{{< /boxmd >}}

We can clearly see that the logger instance is initialised once and injected into wherever necessary.

{{< alert theme="success" dir="ltr" >}}
Find the source code here https://github.com/adhithyakrishna/go-dependency-injection
{{< /alert >}}