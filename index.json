[{"content":"Solution for leetcode 819 Golang Java  Golang solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  func mostCommonWord(paragraph string, banned []string) string { var sb strings.Builder bannedMap := make(map[string]bool) for _, data := range banned { bannedMap[data] = true } wordCounts := make(map[string]int) var max string for _, ch := range paragraph { if string(ch) == \u0026#34; \u0026#34; || string(ch) == \u0026#34;,\u0026#34; { if sb.Len() \u0026gt; 0 { max = addWordToMap(wordCounts, sb, max, bannedMap) sb.Reset() } } else { if unicode.IsLetter(ch) { sb.WriteString(string(ch)) } } } if sb.Len() \u0026gt; 0 { max = addWordToMap(wordCounts, sb, max, bannedMap) } return max } func addWordToMap(wordCounts map[string]int, sb strings.Builder, max string, bannedMap map[string]bool) string { word := strings.ToLower(sb.String()) wordCounts[word] += 1 if !bannedMap[word] \u0026amp;\u0026amp; wordCounts[word] \u0026gt; wordCounts[max] { max = word } return max }   References:\n Are Maps pass by reference in go ?    Java solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Solution { public String mostCommonWord(String paragraph, String[] banned) { Set\u0026lt;String\u0026gt; bannedSet = new HashSet\u0026lt;String\u0026gt;(); for(String ban: banned) { bannedSet.add(ban); } StringBuffer sb = new StringBuffer(); Map\u0026lt;String, Integer\u0026gt; dataMap = new HashMap\u0026lt;String, Integer\u0026gt;(); String max = \u0026#34;\u0026#34;; for(char ch : paragraph.toCharArray()) { if(ch == \u0026#39; \u0026#39; || ch == \u0026#39;,\u0026#39;) { if(sb.length() \u0026gt; 0) { max = addWordToMap(sb, bannedSet, dataMap, max); sb.setLength(0); } } else { if(Character.isAlphabetic(ch)) { sb.append(ch); } } } if(sb.length() \u0026gt; 0) { max = addWordToMap(sb, bannedSet, dataMap, max); } return max; } public String addWordToMap(StringBuffer sb, Set\u0026lt;String\u0026gt; bannedSet, Map\u0026lt;String, Integer\u0026gt; dataMap, String max) { String word = sb.toString().toLowerCase(); if(bannedSet.contains(word)) return max; dataMap.put(word, dataMap.getOrDefault(word, 0) + 1); if(dataMap.get(word) \u0026gt; dataMap.getOrDefault(max, 0)) { return word; } return max; } }       'use strict'; var containerId = JSON.parse(\"\\\"2e3d604510cf6c4c\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Time complexity : O(N + M)\nSpace complexity : O(N + M) ","description":"Solution for Leetcode 819","id":0,"section":"articles","tags":null,"title":"Most Common word","uri":"https://adhithyakrishna.github.io/articles/leetcode/leetcode819/"},{"content":"Solution for leetcode 977 Golang Java  Golang solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func sortedSquares(nums []int) []int { result := make([]int, len(nums)) start := 0 end := len(nums)-1 index := len(nums)-1 for start \u0026lt;= end { if(abs(nums[start]) \u0026gt;= abs(nums[end])) { result[index] = nums[start] * nums[start] start++ } else { result[index] = nums[end] * nums[end] end-- } index-- } return result } func abs(x int) int { if(x \u0026lt; 0) { return x * -1; } return x }     Java solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int[] sortedSquares(int[] nums) { int[] result = new int[nums.length]; int start = 0; int end = nums.length - 1; int index = nums.length - 1; while(start \u0026lt;= end) { if(abs(nums[start]) \u0026lt;= abs(nums[end])) { result[index] = nums[end] * nums[end]; end--; } else { result[index] = nums[start] * nums[start]; start++; } index--; } return result; } public int abs(int data) { return data \u0026lt; 0 ? data * -1 : data; } }       'use strict'; var containerId = JSON.parse(\"\\\"216afdbf67550f67\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Time complexity : O(N)\nSpace complexity : O(N) ","description":"Solution for Leetcode 977","id":1,"section":"articles","tags":null,"title":"Squares of a sorted array","uri":"https://adhithyakrishna.github.io/articles/leetcode/leetcode977/"},{"content":"This post was inspired by an awesome tech talk by Florian Patan at GopherCon UK in 2018 where he goes over creating a goservice in 30 minutes. The interesting take away from the talk was the use of dependency injection to insert a logger instance into the handler.\nMy aim for this article is to dissect dependency injection into smaller chunks to understand how it works.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger := log.New(os.Stdout, \u0026#34;log \u0026#34;, log.LstdFlags|log.Ltime|log.Lshortfile) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(rw http.ResponseWriter, r *http.Request) { logger.Printf(\u0026#34;Inside handler\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;Hello world\u0026#34;)) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) }   Note that new instance of logger has been initialised in line 10.\nThe flags log.LstdFlags define which text to prefix to each log entry generated by the Logger.\nlog.Ltime represents the time at which the log was generated and the log.Lshortfile represents the name of the file from which the log was printed.\nOn executing the file we get the following output.\nlog 2021/02/01 16:44:03 main.go:15: Inside root\nlog 2021/02/01 16:44:03 main.go:15: Inside root\nThe logger instance was generated in main.go file. Suppose we want to create a new router called home. Instead of creating a new instance of logger we can simply inject it into the router. This is where the dependency injection comes into the picture.\nStep 1 : Create a Handler of type struct and initialise a logger variable of the type log.Logger 1 2 3  type Handlers struct { logger *log.Logger }   Step 2 : Create a function constructor to initialise the logger variable. It returns an address of the initialised Handler. 1 2 3 4 5  func NewHandlers(logger *log.Logger) *Handlers { return \u0026amp;Handlers{ logger: logger, } }   Step 3: Handle method takes implementation of http.Handler interface as the second argument, hence serveHttp method has been intialised with the code logic (logger is accesses inside the function). 1 2 3 4 5 6  func (h *Handlers) ServeHTTP(rw http.ResponseWriter, r *http.Request) { h.logger.Printf(\u0026#34;Inside home\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;from home page\u0026#34;)) }   Step 4: Instance of handler is intialised and assigned to a new variable passed to the /home router 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { logger := log.New(os.Stdout, \u0026#34;log \u0026#34;, log.LstdFlags|log.Ltime|log.Lshortfile) h := homePage.NewHandlers(logger) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(rw http.ResponseWriter, r *http.Request) { logger.Printf(\u0026#34;Inside root\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;Hello world\u0026#34;)) }) mux.Handle(\u0026#34;/home\u0026#34;, h) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) }   The output is\nlog 2021/02/01 18:48:55 main.go:18: Inside handler\nlog 2021/02/01 18:49:04 home.go:19: Inside home\nWe can clearly see that the logger instance is initialised once and injected into wherever necessary.\nFind the source code here https://github.com/adhithyakrishna/go-dependency-injection ","description":"An article about dependency injection in golang","id":2,"section":"articles","tags":null,"title":"Dependency injection in golang","uri":"https://adhithyakrishna.github.io/articles/golang/dependencyinjection/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n The emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your siteâ€™s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nðŸ™ˆ ðŸ™ˆ ðŸ™‰ ðŸ™‰ ðŸ™Š ðŸ™Š\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":3,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://adhithyakrishna.github.io/blog/emoji-support/"}]