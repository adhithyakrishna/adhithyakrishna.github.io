[{"content":"Solution for leetcode 819 Golang Java  Golang solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  func mostCommonWord(paragraph string, banned []string) string { var sb strings.Builder bannedMap := make(map[string]bool) for _, data := range banned { bannedMap[data] = true } wordCounts := make(map[string]int) var max string for _, ch := range paragraph { if string(ch) == \u0026#34; \u0026#34; || string(ch) == \u0026#34;,\u0026#34; { if sb.Len() \u0026gt; 0 { max = addWordToMap(wordCounts, sb, max, bannedMap) sb.Reset() } } else { if unicode.IsLetter(ch) { sb.WriteString(string(ch)) } } } if sb.Len() \u0026gt; 0 { max = addWordToMap(wordCounts, sb, max, bannedMap) } return max } func addWordToMap(wordCounts map[string]int, sb strings.Builder, max string, bannedMap map[string]bool) string { word := strings.ToLower(sb.String()) wordCounts[word] += 1 if !bannedMap[word] \u0026amp;\u0026amp; wordCounts[word] \u0026gt; wordCounts[max] { max = word } return max }   References:\n Are Maps pass by reference in go ?    Java solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Solution { public String mostCommonWord(String paragraph, String[] banned) { Set\u0026lt;String\u0026gt; bannedSet = new HashSet\u0026lt;String\u0026gt;(); for(String ban: banned) { bannedSet.add(ban); } StringBuffer sb = new StringBuffer(); Map\u0026lt;String, Integer\u0026gt; dataMap = new HashMap\u0026lt;String, Integer\u0026gt;(); String max = \u0026#34;\u0026#34;; for(char ch : paragraph.toCharArray()) { if(ch == \u0026#39; \u0026#39; || ch == \u0026#39;,\u0026#39;) { if(sb.length() \u0026gt; 0) { max = addWordToMap(sb, bannedSet, dataMap, max); sb.setLength(0); } } else { if(Character.isAlphabetic(ch)) { sb.append(ch); } } } if(sb.length() \u0026gt; 0) { max = addWordToMap(sb, bannedSet, dataMap, max); } return max; } public String addWordToMap(StringBuffer sb, Set\u0026lt;String\u0026gt; bannedSet, Map\u0026lt;String, Integer\u0026gt; dataMap, String max) { String word = sb.toString().toLowerCase(); if(bannedSet.contains(word)) return max; dataMap.put(word, dataMap.getOrDefault(word, 0) + 1); if(dataMap.get(word) \u0026gt; dataMap.getOrDefault(max, 0)) { return word; } return max; } }       'use strict'; var containerId = JSON.parse(\"\\\"2e3d604510cf6c4c\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Time complexity : O(N + M)\nSpace complexity : O(N + M) ","description":"Solution for Leetcode 819","id":0,"section":"articles","tags":null,"title":"Most Common word","uri":"https://adhithyakrishna.github.io/articles/leetcode/leetcode819/"},{"content":"Solution for leetcode 977 Golang Java  Golang solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func sortedSquares(nums []int) []int { result := make([]int, len(nums)) start := 0 end := len(nums)-1 index := len(nums)-1 for start \u0026lt;= end { if(abs(nums[start]) \u0026gt;= abs(nums[end])) { result[index] = nums[start] * nums[start] start++ } else { result[index] = nums[end] * nums[end] end-- } index-- } return result } func abs(x int) int { if(x \u0026lt; 0) { return x * -1; } return x }     Java solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int[] sortedSquares(int[] nums) { int[] result = new int[nums.length]; int start = 0; int end = nums.length - 1; int index = nums.length - 1; while(start \u0026lt;= end) { if(abs(nums[start]) \u0026lt;= abs(nums[end])) { result[index] = nums[end] * nums[end]; end--; } else { result[index] = nums[start] * nums[start]; start++; } index--; } return result; } public int abs(int data) { return data \u0026lt; 0 ? data * -1 : data; } }       'use strict'; var containerId = JSON.parse(\"\\\"216afdbf67550f67\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Time complexity : O(N)\nSpace complexity : O(N) ","description":"Solution for Leetcode 977","id":1,"section":"articles","tags":null,"title":"Squares of a sorted array","uri":"https://adhithyakrishna.github.io/articles/leetcode/leetcode977/"},{"content":"Course Notes for Kubernetes crash course of java developers This article contains the notes for the Kubernetes crash course of java developers by Ranga Rao on Udemy. You can find this course here.\nThis is my first attempt to create notes for courses.\nClick on the image to open the pdf\n\n","description":"An article about Docker","id":2,"section":"notes","tags":null,"title":"kubernetes crash course for java developers","uri":"https://adhithyakrishna.github.io/notes/courses/kubernetes-crash-course-for-java-developers/"},{"content":"This post was inspired by an awesome tech talk by Florian Patan at GopherCon UK in 2018 where he goes over creating a goservice in 30 minutes. The interesting take away from the talk was the use of dependency injection to insert a logger instance into the handler.\nMy aim for this article is to dissect dependency injection into smaller chunks to understand how it works.\nThe initial code for the project is given below. (main.go)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger := log.New(os.Stdout, \u0026#34;log \u0026#34;, log.LstdFlags|log.Ltime|log.Lshortfile) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(rw http.ResponseWriter, r *http.Request) { logger.Printf(\u0026#34;Inside handler\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;Hello world\u0026#34;)) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) }   Note that new instance of logger has been initialised in line 10.\nThe flags log.LstdFlags define which text to prefix to each log entry generated by the Logger.\nlog.Ltime represents the time at which the log was generated and the log.Lshortfile represents the name of the file from which the log was printed.\nOn executing the file we get the following output.\nlog 2021/02/01 16:44:03 main.go:15: Inside root\nlog 2021/02/01 16:44:03 main.go:15: Inside root\nThe logger instance was generated in main.go file. Suppose we want to create a new router called home. Instead of creating a new instance of logger we can simply inject it into the router. This is where the dependency injection comes into the picture.\nWe create a new package that handles the logic of /home route. The new package is home package. In the home.go file, we add the following code.\nDependency Injection Step 1 : Create a Handler of type struct and initialise a logger variable of the type log.Logger 1 2 3  type Handlers struct { logger *log.Logger }   Step 2 : Create a function constructor to initialise the logger variable. It returns an address of the initialised Handler. 1 2 3 4 5  func NewHandlers(logger *log.Logger) *Handlers { return \u0026amp;Handlers{ logger: logger, } }   Step 3: Handle method takes implementation of http.Handler interface as the second argument, hence serveHttp method has been intialised with the code logic (logger is accesses inside the function). 1 2 3 4 5 6  func (h *Handlers) ServeHTTP(rw http.ResponseWriter, r *http.Request) { h.logger.Printf(\u0026#34;Inside home\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;from home page\u0026#34;)) }   Step 4: Instance of handler is intialised and assigned to a new variable passed to the /home router 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { logger := log.New(os.Stdout, \u0026#34;log \u0026#34;, log.LstdFlags|log.Ltime|log.Lshortfile) h := homePage.NewHandlers(logger) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(rw http.ResponseWriter, r *http.Request) { logger.Printf(\u0026#34;Inside root\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;Hello world\u0026#34;)) }) mux.Handle(\u0026#34;/home\u0026#34;, h) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) }   The output is\nlog 2021/02/01 18:48:55 main.go:18: Inside handler\nlog 2021/02/01 18:49:04 home.go:19: Inside home\nWe can clearly see that the logger instance is initialised once and injected into wherever necessary.\nFind the source code here https://github.com/adhithyakrishna/go-dependency-injection ","description":"An article about dependency injection in golang","id":3,"section":"articles","tags":null,"title":"Dependency injection in golang","uri":"https://adhithyakrishna.github.io/articles/golang/dependencyinjection/"},{"content":"This article explains embedding interfaces concept in golang. We first begin by writing the main crux of the code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type Animal struct { Dog } type Dog struct { } func (d Dog) speak() { fmt.Println(\u0026#34;woof\u0026#34;) } func main() { d := Animal{Dog{}} d.speak(); v := Animal{} v.speak(); }   In the above code we declare a type of struct named Dog. There is a method embedded to the Dog struct called speak.\nWe declare a new struct Animal, which has Dog as one of if its fields. Now, All the methods embedded on the struct Dog can be accessed by creating a variable for the struct type Animal (Line 14).\nThough this works fine, the problem here is, the struct Animal has a field Dog hardcoded to it. Suppose we have to include a cat, we have to then alter the struct Animal to include cat. It doesnt end there, we\u0026rsquo;ll also have to modify the variable initialisation to include Cat. Now, since both dog and cat has the function speak we will have to explicitly specify which function are we intending to call. Code including cat is given below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  type Animal struct { Dog Cat } type Dog struct { } func (d Dog) speak() { fmt.Println(\u0026#34;woof\u0026#34;) } type Cat struct { } func (c Cat) speak() { fmt.Println(\u0026#34;meow\u0026#34;) } func main() { d := Animal{ Dog{}, Cat{}, } d.Cat.speak(); }   To make it easy for us to swap between different animals, or include multiple animals, we can make use of Interfaces.\nInterfaces Step 1: Create a type of interface that encompasses the common functionalites. 1 2 3  type Language interface { speak() }   Now, any type that implements speak function is an implementation of the Language interface.\nStep 2: Create a type of struct Dog, and implement the functions of the interface. 1 2 3 4 5  type Dog struct {} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) }   Step 3: Include the interface as a field to the Animal struct 1 2 3  type Animal struct { Language }   Now, any struct that implements the speak function can be initialised to the Language field during declaration. We need not disturb the Animal struct again.\nInvoking the speak function for Dog is just a matter of initialising the variable with the struct Animal with any one of the implementations of the Language interface as below.\n1 2  d := Animal{Dog{}} d.speak();   Including a new animal is easy. All we have to do is, create a new struct (Ex. Cat), embed a function speak() to the struct.\n1 2 3 4 5  type Cat struct {} func (d Cat) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) }   The realworld advantage to doing this is that, now any time we decide to replace a funcionality, say, we have included some customer specific logic, it is as easy as swapping it with the new struct that implements the interface.\nFull code can be found below\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import \u0026#34;fmt\u0026#34; type Animal struct { Language } type Dog struct {} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) } type Cat struct {} func (d Cat) speak() { fmt.Println(\u0026#34;Meow\u0026#34;) } type Language interface { speak() } func main() { d := Animal{Dog{}} d.speak(); c := Animal{Cat{}} c.speak(); }   In line 23, Dog can be replaced by Cat and just by swapping, we can include functionality of cat instead of dog.\nThe output is\nWoof\nMeow\nFind the source code here https://gist.github.com/adhithyakrishna/ac72d0d4af806b764d66fda8efec8728 ","description":"An article about embedding in golang","id":4,"section":"articles","tags":null,"title":"Embedding Interfaces","uri":"https://adhithyakrishna.github.io/articles/golang/embeddinginterfaces/"},{"content":"This article is a continuation to the previous article about Embedding interfaces found here\nWe start from the crux of the previous code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import \u0026#34;fmt\u0026#34; type Animal struct { Language } type Dog struct {} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) } type Cat struct {} func (d Cat) speak() { fmt.Println(\u0026#34;Meow\u0026#34;) } type Language interface { speak() } func main() { d := Animal{Dog{}} d.speak(); c := Animal{Cat{}} c.speak(); }   Now, Let us say, we work for a client who wants add a functionality. It may be something like, adding a prefix to the language spoken by the animal.\nTo do that, we can make use of the concept called interface chaining.\nDeclare a type struct that includes the interface as one of its field. It should also include implementations of the speak function. 1 2 3 4 5 6 7 8  type Initiator struct { Language } func (i Initiator) speak() { fmt.Print(\u0026#34;The animal says : \u0026#34;, i) i.Language.speak() }   Now Inititator struct implements the language interface. Since it includes, Language interface as one of its fields, chaining is very easy to do.\n1 2  c := Animal{Initiator{Cat{}}} c.speak()   The Initiator functionality has been chained into the variable declaration. Now everytime a speak function is called on the intialised variable, first, the speak function in the initiator struct would be called and then, the speak function in the Cat struct would take place.\nFull code is given below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import \u0026#34;fmt\u0026#34; type Animal struct { Language } type Dog struct{} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) } type Cat struct{} func (d Cat) speak() { fmt.Println(\u0026#34;Meow\u0026#34;) } type Language interface { speak() } type Initiator struct { Language } func (i Initiator) speak() { fmt.Print(\u0026#34;The animal says : \u0026#34;) i.Language.speak() } func main() { d := Animal{Dog{}} d.speak() c := Animal{Initiator{Cat{}}} c.speak() }   The output is\nWoof\nThe animal says : Meow\nFind the source code here https://gist.github.com/adhithyakrishna/ad5cb9b6f4ce1d5bb98407f9502e51ee ","description":"An article about Chaining interfaces in golang","id":5,"section":"articles","tags":null,"title":"Chaining Interfaces","uri":"https://adhithyakrishna.github.io/articles/golang/chaininginterfaces/"},{"content":"Golang lets us declare a variable of type functions. In Golang functions are first class citizens. In this article we are going to see how the functions can be used a type in golang.\nDeclaration of the variable 1  type validator func(*User) error   validator is the name of the variable that has a type function which takes the struct User as its argument and returns an error.\nDeclaration of struct and functions on the struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type userValidator struct {} func (uv *userValidator)validateEmail(u *User) error { matched, _ := regexp.MatchString(`^[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,16}$`, u.email) if !matched { return ErrEmailInvalid } return nil } func (uv *userValidator) isEmpty(u *User) error { if u.email == \u0026#34;\u0026#34; { return ErrEmailEmpty } return nil }   If we observe, we can note that the function argument as well the return type matches the variable we declared above. Now we can pass validator as an argument to different functions and execute them. Below is an example.\n1 2 3 4 5 6 7 8  func runUserValidations(user *User, fns ...validator) error { for _, fns := range fns { if err:=fns(user); err != nil { return err } } return nil }   You can see that, validator is passed as an argument to the runUserValidations functions. The function can be executed by passing an instance of user struct as an argument.\nI have included an example below of how using function types will come in handy while doing multiple functions that validates if an email is valid.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) var ( ErrEmailInvalid = errors.New(\u0026#34;email address is not valid\u0026#34;) ErrEmailEmpty = errors.New(\u0026#34;email address is empty\u0026#34;) ) type User struct { email string } type userValidator struct {} type validator func(*User) error func (uv *userValidator)validateEmail(u *User) error { matched, _ := regexp.MatchString(`^[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,16}$`, u.email) if !matched { return ErrEmailInvalid } return nil } func (uv *userValidator) isEmpty(u *User) error { if u.email == \u0026#34;\u0026#34; { return ErrEmailEmpty } return nil } func runUserValidations(user *User, fns ...validator) error { for _, fns := range fns { if err:=fns(user); err != nil { return err } } return nil } func main() { u := User{ email: \u0026#34;adhithya.awesome@gmail.com\u0026#34;, } uv := userValidator{} err:= runUserValidations(\u0026amp;u, uv.isEmpty, uv.validateEmail) if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;valid email\u0026#34;) }   If you note line number 52 in the above code you can see how an instance of user struct, initialised with an email is passed to different functions, validated and if there is an error in the validation it prints the error or it prints the email is valid.\nWe can included multiple such functions and calling them is a matter of including them to the runUserValidations functions.\n","description":"An article about function types in golang","id":6,"section":"articles","tags":null,"title":"Function types","uri":"https://adhithyakrishna.github.io/articles/golang/functiontypes/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n The emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your siteâ€™s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nðŸ™ˆ ðŸ™ˆ ðŸ™‰ ðŸ™‰ ðŸ™Š ðŸ™Š\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":7,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://adhithyakrishna.github.io/blog/emoji-support/"}]