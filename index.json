[{"content":"Solution for leetcode 819 Golang Java  Golang solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  func mostCommonWord(paragraph string, banned []string) string { var sb strings.Builder bannedMap := make(map[string]bool) for _, data := range banned { bannedMap[data] = true } wordCounts := make(map[string]int) var max string for _, ch := range paragraph { if string(ch) == \u0026#34; \u0026#34; || string(ch) == \u0026#34;,\u0026#34; { if sb.Len() \u0026gt; 0 { max = addWordToMap(wordCounts, sb, max, bannedMap) sb.Reset() } } else { if unicode.IsLetter(ch) { sb.WriteString(string(ch)) } } } if sb.Len() \u0026gt; 0 { max = addWordToMap(wordCounts, sb, max, bannedMap) } return max } func addWordToMap(wordCounts map[string]int, sb strings.Builder, max string, bannedMap map[string]bool) string { word := strings.ToLower(sb.String()) wordCounts[word] += 1 if !bannedMap[word] \u0026amp;\u0026amp; wordCounts[word] \u0026gt; wordCounts[max] { max = word } return max }   References:\n Are Maps pass by reference in go ?    Java solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class Solution { public String mostCommonWord(String paragraph, String[] banned) { Set\u0026lt;String\u0026gt; bannedSet = new HashSet\u0026lt;String\u0026gt;(); for(String ban: banned) { bannedSet.add(ban); } StringBuffer sb = new StringBuffer(); Map\u0026lt;String, Integer\u0026gt; dataMap = new HashMap\u0026lt;String, Integer\u0026gt;(); String max = \u0026#34;\u0026#34;; for(char ch : paragraph.toCharArray()) { if(ch == \u0026#39; \u0026#39; || ch == \u0026#39;,\u0026#39;) { if(sb.length() \u0026gt; 0) { max = addWordToMap(sb, bannedSet, dataMap, max); sb.setLength(0); } } else { if(Character.isAlphabetic(ch)) { sb.append(ch); } } } if(sb.length() \u0026gt; 0) { max = addWordToMap(sb, bannedSet, dataMap, max); } return max; } public String addWordToMap(StringBuffer sb, Set\u0026lt;String\u0026gt; bannedSet, Map\u0026lt;String, Integer\u0026gt; dataMap, String max) { String word = sb.toString().toLowerCase(); if(bannedSet.contains(word)) return max; dataMap.put(word, dataMap.getOrDefault(word, 0) + 1); if(dataMap.get(word) \u0026gt; dataMap.getOrDefault(max, 0)) { return word; } return max; } }       'use strict'; var containerId = JSON.parse(\"\\\"2e3d604510cf6c4c\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Time complexity : O(N + M)\nSpace complexity : O(N + M) ","description":"Solution for Leetcode 819","id":0,"section":"articles","tags":null,"title":"Most Common word","uri":"https://adhithyakrishna.github.io/articles/leetcode/leetcode819/"},{"content":"Solution for leetcode 977 Golang Java  Golang solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func sortedSquares(nums []int) []int { result := make([]int, len(nums)) start := 0 end := len(nums)-1 index := len(nums)-1 for start \u0026lt;= end { if(abs(nums[start]) \u0026gt;= abs(nums[end])) { result[index] = nums[start] * nums[start] start++ } else { result[index] = nums[end] * nums[end] end-- } index-- } return result } func abs(x int) int { if(x \u0026lt; 0) { return x * -1; } return x }     Java solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution { public int[] sortedSquares(int[] nums) { int[] result = new int[nums.length]; int start = 0; int end = nums.length - 1; int index = nums.length - 1; while(start \u0026lt;= end) { if(abs(nums[start]) \u0026lt;= abs(nums[end])) { result[index] = nums[end] * nums[end]; end--; } else { result[index] = nums[start] * nums[start]; start++; } index--; } return result; } public int abs(int data) { return data \u0026lt; 0 ? data * -1 : data; } }       'use strict'; var containerId = JSON.parse(\"\\\"216afdbf67550f67\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Time complexity : O(N)\nSpace complexity : O(N) ","description":"Solution for Leetcode 977","id":1,"section":"articles","tags":null,"title":"Squares of a sorted array","uri":"https://adhithyakrishna.github.io/articles/leetcode/leetcode977/"},{"content":"  This notes is for the course Kuberenetes for absolute beginners\nIntroduction Container orchestration system = Container + Orchestration\nWhat are containers  Containers have their own processes, network and mounts Multiple containers can share the underlying operating system kernel.  Docker (most popular container technology).\nProblems before containers  Application component and services being incompatible with underlying OS. Compatibility between services, libraries and dependencies on the OS. Compatability checks had to be make during every component upgrade AKA matrix from hell. Onboarding a new developer / setting up a local instance was difficult.  With docker  Each component can run in its own container with its own libraries and dependencies. Docker is compatible with any operating systems. Onboarding a new developer / setting up a local instance is very easy.  Os components and responsibilities All operating sytems consists of two important components\n OS Kernel Software  Os kernel is responsible for interacting with underlying hardware. Custom software differentiates operating systems from each other. Docker container shares the underlying kernel of docker host. Docker is not meant to virualize and run different operating systems on the same hardware. The main purpose is to containerize and ship them.\nDocker vs Virtual machines  Containers vs Virtual Machine: https://www.udemy.com/course/learn-kubernetes/   In case of docker we have\n Underlying hardware infrastructure. Operating system Docker installed on the OS (which is responsible for managing the containers that run with libraries and dependencies).  In case of virual machine\n Underlying hardware infrastructure Operating system Hypervisor (ESX or virtualization) Virtual machine Virual machine has its own OS inside Dependencies Application  The overhead causes higher utilization of underlying resources because there are multiple operating systems and kernel running. The Virtual machine is heavy and consume high disk space (Gigabytes) whereas Docker containers a re light weight and are usually mega bytes in size.\nDocker containers boot up faster (within seconds). VM takes minutes to boot up as it needs to boot up the entire OS.\nDocker has less isolation as more resources (like kernel) are shared between containers.\nFor VMs, there is complete isolation. Since VM does not directly rely on underlying OS or kernel, we can run different OS such as linux / windows based on same hypervisor.\n\u0026ldquo;Hypervisors and containers are used for different purposes. Hypervisors are used to create and run virtual machines (VMs), which each have their own complete operating systems, securely isolated from the others. In contrast to VMs, containers package up just an app and its related services. This makes them more lightweight and portable than VMs, so they are often used for fast and flexible application development and movement.\u0026rdquo;\nReference : https://www.vmware.com/topics/glossary/content/hypervisor.html?resource=cat-1023790256#cat-1023790256 Image vs Containers An image is a package or a template that is used to create one or more containers.\nContainers are running instances of that image that are isolated and have their own environments and set of processes.\nAdvantage of containers Traditonally, developers developed applications and hand it over to Ops team to deploy and manage it in production environments along with some instructions. If they hit an issue, they would have to work with developers to resolve it.\nWith docker, major portion of this infrastructure setup is now in the hands of developers in form of Docker file. The instructions that were put to gether previously (handed off to the ops team) can now put together easily into a Dockerfile (to create an image for their application). The image can run on any container platform and is guaranteed to run the same way everywhere. Ops team can now use the image to deploy the application. Since OPS team are not modifying it, it continues to work the same when deployed in production.\n","description":"Introduction to Kubernetes","id":2,"section":"notes","tags":null,"title":"Introduction","uri":"https://adhithyakrishna.github.io/notes/k8s_for_absolute_beginners/introduction/"},{"content":"This post was inspired by an awesome tech talk by Florian Patan at GopherCon UK in 2018 where he goes over creating a goservice in 30 minutes. The interesting take away from the talk was the use of dependency injection to insert a logger instance into the handler.\nMy aim for this article is to dissect dependency injection into smaller chunks to understand how it works.\nThe initial code for the project is given below. (main.go)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger := log.New(os.Stdout, \u0026#34;log \u0026#34;, log.LstdFlags|log.Ltime|log.Lshortfile) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(rw http.ResponseWriter, r *http.Request) { logger.Printf(\u0026#34;Inside handler\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;Hello world\u0026#34;)) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) }   Note that new instance of logger has been initialised in line 10.\nThe flags log.LstdFlags define which text to prefix to each log entry generated by the Logger.\nlog.Ltime represents the time at which the log was generated and the log.Lshortfile represents the name of the file from which the log was printed.\nOn executing the file we get the following output.\nlog 2021/02/01 16:44:03 main.go:15: Inside root\nlog 2021/02/01 16:44:03 main.go:15: Inside root\nThe logger instance was generated in main.go file. Suppose we want to create a new router called home. Instead of creating a new instance of logger we can simply inject it into the router. This is where the dependency injection comes into the picture.\nWe create a new package that handles the logic of /home route. The new package is home package. In the home.go file, we add the following code.\nDependency Injection Step 1 : Create a Handler of type struct and initialise a logger variable of the type log.Logger 1 2 3  type Handlers struct { logger *log.Logger }   Step 2 : Create a function constructor to initialise the logger variable. It returns an address of the initialised Handler. 1 2 3 4 5  func NewHandlers(logger *log.Logger) *Handlers { return \u0026amp;Handlers{ logger: logger, } }   Step 3: Handle method takes implementation of http.Handler interface as the second argument, hence serveHttp method has been intialised with the code logic (logger is accesses inside the function). 1 2 3 4 5 6  func (h *Handlers) ServeHTTP(rw http.ResponseWriter, r *http.Request) { h.logger.Printf(\u0026#34;Inside home\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;from home page\u0026#34;)) }   Step 4: Instance of handler is intialised and assigned to a new variable passed to the /home router 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { logger := log.New(os.Stdout, \u0026#34;log \u0026#34;, log.LstdFlags|log.Ltime|log.Lshortfile) h := homePage.NewHandlers(logger) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(rw http.ResponseWriter, r *http.Request) { logger.Printf(\u0026#34;Inside root\u0026#34;) rw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=utf-8\u0026#34;) rw.WriteHeader(http.StatusOK) rw.Write([]byte(\u0026#34;Hello world\u0026#34;)) }) mux.Handle(\u0026#34;/home\u0026#34;, h) http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux) }   The output is\nlog 2021/02/01 18:48:55 main.go:18: Inside handler\nlog 2021/02/01 18:49:04 home.go:19: Inside home\nWe can clearly see that the logger instance is initialised once and injected into wherever necessary.\nFind the source code here https://github.com/adhithyakrishna/go-dependency-injection ","description":"An article about dependency injection in golang","id":3,"section":"articles","tags":null,"title":"Dependency injection in golang","uri":"https://adhithyakrishna.github.io/articles/golang/dependencyinjection/"},{"content":"  This notes is for the course Kuberenetes for absolute beginners\nContainer orchestration Kubernetes is a Container Orchestration technology. Docker has its own container orchestraction - docker swarm. There is also MESOS from Apache.\nThe process of automatically deploying and managing containers (scaling up when load increases and scaling down when load decreases) is known as Container Orchestration.\nAdvantages of container orchestration\n Application is highly available, since there are multiple instances of the application running on different nodes. User traffic is load balanced across various containers. When demand increases, deploy more instances of the application seamlessly this can be done at the service level. When we run out of hardware, we can scale the number of nodes up/down without having to take down the application. All of the above can be done with a set of declarative object configuration files.  Kubernetes components Nodes Node is a machine (physical or virtual) on which k8s is installed. A node is worker machine and this is going to hold the containers launched by kubernetes.\n K8s Nodes: https://www.udemy.com/course/learn-kubernetes/   Cluster Cluster is a set of nodes grouped together. This way, even if one node fails, the application is still accessible from other nodes.\nMultiple nodes would help with sharing load as well.\nMaster Master is another node with kubernetes installed in it and is configured as a master. The master watches over the nodes in the cluster and is responsible for the actual orchestraction of containers on the worker nodes.\nFew responsibilites of master node\n Responsible for managing the cluster. Stores the information about the members of the cluster. Monitor nodes. Moving the workload of the failed nodes to another worker nodes.  Components of Kubernetes (Control plane) When a k8s is installed on a system, the following componenets are also installed\n K8s Components: https://www.udemy.com/course/learn-kubernetes/   1) An API server - An API server acts as a front-end for kubernetes. The users, management devices, CLI all talk to the API server to interact with kubernetes.\n2) An ETCD service - It is a reliable key-value store to store all the data used to manage the cluster. ETCD stores the information of multiple nodes and multiple masters in the k8s cluster in a distributed manner. ETCD is also responsible for implementing locks within the cluster to ensure there are no conflicts between the masters.\n3) A Kubelet service - It is an agent that runs on each node in the cluster. It is responsible for making sure that containers are running on the nodes as expected.\n4) A Container runtime - An underlying software that is used to run the containers. (Docker)\n5) Controllers - They are the brain behind the orchestration. They notice and respond when the nodes, containers or endpoints go down. The controllers would make decisions to bring up new containers in such case.\n6) Schedulers - Reponsible for distributing work or containers across multiple nodes. It looks for newly created containers and assigns them to Nodes.\nThe following factors are taken into account for scheduling decisions\n Induvidual and collective resource requirements Hardware/software/policy constraints Affinity and anti-affinity specifications Data locality Inter-workload interference deadlines  Master vs Nodes  Master vs worker nodes: https://www.udemy.com/course/learn-kubernetes/   The master node has\n Kube-apiserver installed ETCD Control manager Scheduler and more.  Worker node has\n Container run time installed. Kubelet agent - provides health information of the worker node to the master and carry out the actions requested by the master on the worker nodes.  Kubectl (kube control) Tool used to deploy and manage applications on a Kubernetes cluster\n Provide cluster information Get status of nodes in the cluster  Pod Kubernetes does not deploy containers directly on the worker nodes. The containers are encapsulated into a kubernetes objects known as pods. A Pod is a single instance of an application and is the smallest object that can be created in kubernetes.\nTo scale up an application, we create a new pod instead of creating additional container inside of an existing pod. A pod can hold additional containers as well (usually not of the same kind). The additional container can be a helper container that supports the main application. The two containers can communicate with each other directly by referring to each other as localhost since they share the same network namespace. They share the same storage space as well.\n","description":"Kubernetes architecture","id":4,"section":"notes","tags":null,"title":"Kubernetes architecture","uri":"https://adhithyakrishna.github.io/notes/k8s_for_absolute_beginners/k8s_architecture/"},{"content":"This article explains embedding interfaces concept in golang. We first begin by writing the main crux of the code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type Animal struct { Dog } type Dog struct { } func (d Dog) speak() { fmt.Println(\u0026#34;woof\u0026#34;) } func main() { d := Animal{Dog{}} d.speak(); v := Animal{} v.speak(); }   In the above code we declare a type of struct named Dog. There is a method embedded to the Dog struct called speak.\nWe declare a new struct Animal, which has Dog as one of if its fields. Now, All the methods embedded on the struct Dog can be accessed by creating a variable for the struct type Animal (Line 14).\nThough this works fine, the problem here is, the struct Animal has a field Dog hardcoded to it. Suppose we have to include a cat, we have to then alter the struct Animal to include cat. It doesnt end there, we\u0026rsquo;ll also have to modify the variable initialisation to include Cat. Now, since both dog and cat has the function speak we will have to explicitly specify which function are we intending to call. Code including cat is given below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  type Animal struct { Dog Cat } type Dog struct { } func (d Dog) speak() { fmt.Println(\u0026#34;woof\u0026#34;) } type Cat struct { } func (c Cat) speak() { fmt.Println(\u0026#34;meow\u0026#34;) } func main() { d := Animal{ Dog{}, Cat{}, } d.Cat.speak(); }   To make it easy for us to swap between different animals, or include multiple animals, we can make use of Interfaces.\nInterfaces Step 1: Create a type of interface that encompasses the common functionalites. 1 2 3  type Language interface { speak() }   Now, any type that implements speak function is an implementation of the Language interface.\nStep 2: Create a type of struct Dog, and implement the functions of the interface. 1 2 3 4 5  type Dog struct {} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) }   Step 3: Include the interface as a field to the Animal struct 1 2 3  type Animal struct { Language }   Now, any struct that implements the speak function can be initialised to the Language field during declaration. We need not disturb the Animal struct again.\nInvoking the speak function for Dog is just a matter of initialising the variable with the struct Animal with any one of the implementations of the Language interface as below.\n1 2  d := Animal{Dog{}} d.speak();   Including a new animal is easy. All we have to do is, create a new struct (Ex. Cat), embed a function speak() to the struct.\n1 2 3 4 5  type Cat struct {} func (d Cat) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) }   The realworld advantage to doing this is that, now any time we decide to replace a funcionality, say, we have included some customer specific logic, it is as easy as swapping it with the new struct that implements the interface.\nFull code can be found below\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import \u0026#34;fmt\u0026#34; type Animal struct { Language } type Dog struct {} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) } type Cat struct {} func (d Cat) speak() { fmt.Println(\u0026#34;Meow\u0026#34;) } type Language interface { speak() } func main() { d := Animal{Dog{}} d.speak(); c := Animal{Cat{}} c.speak(); }   In line 23, Dog can be replaced by Cat and just by swapping, we can include functionality of cat instead of dog.\nThe output is\nWoof\nMeow\nFind the source code here https://gist.github.com/adhithyakrishna/ac72d0d4af806b764d66fda8efec8728 ","description":"An article about embedding in golang","id":5,"section":"articles","tags":null,"title":"Embedding Interfaces","uri":"https://adhithyakrishna.github.io/articles/golang/embeddinginterfaces/"},{"content":"  This notes is for the course Kuberenetes for absolute beginners\nYaml introduction According to yaml.org, \u0026ldquo;YAML is a human-friendly, data serialization standard for all programming languages.\u0026quot;\nYaml is used to create kubernetes configurations\nStructure of YAML file Key Value Pair The basic type of entry in a YAML file is of a key value pair. After the Key and colon there is a space and then the value.\nFruit: Apple Vegetable: Radish Liquid: Water Array/List Lists would have a name and a number of items listed under it. The elements of the list would start with a -. There can be a n of lists, however the indentation of various elements of the array matters a lot.\nFruits: - Orange - Banana - Mango Vegetables: - Potato - Tomato - Carrot Dictionary/Map A more complex type of YAML file would be a Dictionary/Map.\nBanana: Calories: 200 Fat: 0.5g Carbs: 30g Grapes: Calories: 100 Fat: 0.4g Carbs: 20g It is important to indent Yaml properly. Improper indentation would break a sibling / parent relationship between the properties. Advanced YAML structures List containing a list of dictionaries. - Fruits: - Banana: Calories: 105 Fat: 0.4g Carbs: 27g - Grape: Calories: 62 Fat: 0.3g Carbs: 16g - Vegetables: - Potato: Calories: 105 Fat: 0.4g Carbs: 27g Dictionary in Dictionary Banana: type: name: musa Calories: 200 Fat: 0.5g Carbs: 30g A list is ordered\nA dictionary is unordered ","description":"Yaml Introduction","id":6,"section":"notes","tags":null,"title":"Yaml Introduction","uri":"https://adhithyakrishna.github.io/notes/k8s_for_absolute_beginners/yaml_introduction/"},{"content":"This article is a continuation to the previous article about Embedding interfaces found here\nWe start from the crux of the previous code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  import \u0026#34;fmt\u0026#34; type Animal struct { Language } type Dog struct {} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) } type Cat struct {} func (d Cat) speak() { fmt.Println(\u0026#34;Meow\u0026#34;) } type Language interface { speak() } func main() { d := Animal{Dog{}} d.speak(); c := Animal{Cat{}} c.speak(); }   Now, Let us say, we work for a client who wants add a functionality. It may be something like, adding a prefix to the language spoken by the animal.\nTo do that, we can make use of the concept called interface chaining.\nDeclare a type struct that includes the interface as one of its field. It should also include implementations of the speak function. 1 2 3 4 5 6 7 8  type Initiator struct { Language } func (i Initiator) speak() { fmt.Print(\u0026#34;The animal says : \u0026#34;, i) i.Language.speak() }   Now Inititator struct implements the language interface. Since it includes, Language interface as one of its fields, chaining is very easy to do.\n1 2  c := Animal{Initiator{Cat{}}} c.speak()   The Initiator functionality has been chained into the variable declaration. Now everytime a speak function is called on the intialised variable, first, the speak function in the initiator struct would be called and then, the speak function in the Cat struct would take place.\nFull code is given below:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import \u0026#34;fmt\u0026#34; type Animal struct { Language } type Dog struct{} func (d Dog) speak() { fmt.Println(\u0026#34;Woof\u0026#34;) } type Cat struct{} func (d Cat) speak() { fmt.Println(\u0026#34;Meow\u0026#34;) } type Language interface { speak() } type Initiator struct { Language } func (i Initiator) speak() { fmt.Print(\u0026#34;The animal says : \u0026#34;) i.Language.speak() } func main() { d := Animal{Dog{}} d.speak() c := Animal{Initiator{Cat{}}} c.speak() }   The output is\nWoof\nThe animal says : Meow\nFind the source code here https://gist.github.com/adhithyakrishna/ad5cb9b6f4ce1d5bb98407f9502e51ee ","description":"An article about Chaining interfaces in golang","id":7,"section":"articles","tags":null,"title":"Chaining Interfaces","uri":"https://adhithyakrishna.github.io/articles/golang/chaininginterfaces/"},{"content":"  This notes is for the course Kuberenetes for absolute beginners\nKubernetes definition file A Kubernetes definition file always contains 4 top level fields. These are required fields\napiVersion: kind: metadata: . . . spec:  apiVersion - Version of k8s API kind - type of object (pod, replicaset, service, deployment) metadata - data about the object (name and label), it is in the form of a dictionary. Here name is a string value and labels is a dictionary. Labels are useful to identify objects at a later point in time.  metadata: name: myapp-pod labels: app: myapp spec - (specification) where we provide additional information to k8s pertaining to that object. Spec is a dictionary, we can add properties to it, containers in this example, which is a list. The reason this property is a list is because the PODs can have multiple containers within them.  spec: containers: - name: nginx-container image: nginx Few of the kubectl commands kubectl create -f pod-definition.yml kubectl get pods kubectl describe pods ","description":"Yaml for Kubernetes","id":8,"section":"notes","tags":null,"title":"Yaml for Kubernetes","uri":"https://adhithyakrishna.github.io/notes/k8s_for_absolute_beginners/yaml_for_k8s/"},{"content":"Golang lets us declare a variable of type functions. In Golang functions are first class citizens. In this article we are going to see how the functions can be used a type in golang.\nDeclaration of the variable 1  type validator func(*User) error   validator is the name of the variable that has a type function which takes the struct User as its argument and returns an error.\nDeclaration of struct and functions on the struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  type userValidator struct {} func (uv *userValidator)validateEmail(u *User) error { matched, _ := regexp.MatchString(`^[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,16}$`, u.email) if !matched { return ErrEmailInvalid } return nil } func (uv *userValidator) isEmpty(u *User) error { if u.email == \u0026#34;\u0026#34; { return ErrEmailEmpty } return nil }   If we observe, we can note that the function argument as well the return type matches the variable we declared above. Now we can pass validator as an argument to different functions and execute them. Below is an example.\n1 2 3 4 5 6 7 8  func runUserValidations(user *User, fns ...validator) error { for _, fns := range fns { if err:=fns(user); err != nil { return err } } return nil }   You can see that, validator is passed as an argument to the runUserValidations functions. The function can be executed by passing an instance of user struct as an argument.\nI have included an example below of how using function types will come in handy while doing multiple functions that validates if an email is valid.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) var ( ErrEmailInvalid = errors.New(\u0026#34;email address is not valid\u0026#34;) ErrEmailEmpty = errors.New(\u0026#34;email address is empty\u0026#34;) ) type User struct { email string } type userValidator struct {} type validator func(*User) error func (uv *userValidator)validateEmail(u *User) error { matched, _ := regexp.MatchString(`^[a-z0-9._%+\\-]+@[a-z0-9.\\-]+\\.[a-z]{2,16}$`, u.email) if !matched { return ErrEmailInvalid } return nil } func (uv *userValidator) isEmpty(u *User) error { if u.email == \u0026#34;\u0026#34; { return ErrEmailEmpty } return nil } func runUserValidations(user *User, fns ...validator) error { for _, fns := range fns { if err:=fns(user); err != nil { return err } } return nil } func main() { u := User{ email: \u0026#34;adhithya.awesome@gmail.com\u0026#34;, } uv := userValidator{} err:= runUserValidations(\u0026amp;u, uv.isEmpty, uv.validateEmail) if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;valid email\u0026#34;) }   If you note line number 52 in the above code you can see how an instance of user struct, initialised with an email is passed to different functions, validated and if there is an error in the validation it prints the error or it prints the email is valid.\nWe can included multiple such functions and calling them is a matter of including them to the runUserValidations functions.\n","description":"An article about function types in golang","id":9,"section":"articles","tags":null,"title":"Function types","uri":"https://adhithyakrishna.github.io/articles/golang/functiontypes/"},{"content":"  This notes is for the course Kuberenetes for absolute beginners\nReplication controller  Replication controller helps us run multiple instance of a pod in kubernetes cluster, thus providing high availability. Replication controller is capable of ensuring that the specified number of pods are running at all times. It is also capable of load balancing betweening multiple pods to share the loads. It can load balance pods and can do it when pods are in different nodes as well. It allows us to scale the application when demand increases.  apiVersion: v1 kind: ReplicationController metadata: name: myapp-rc labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: frontend spec: containers: - name: nginx-container image: nginx replicas: 3 \u0026gt; kubectl get replicationcontroller Replica Set Replication controller that we saw previously is being replaced by replica set. Replica Set is the recommended way to setup replication.\nOne difference between Replication Controller and Replica Set is, Replica Set requires a selector definition to identify what pods fall under it. Replica Set will take those pods that are already deployed that match the selector definition when creating the replicas.\nReplica Set can also be used to monitor the existing pods and redploy if one of them fails.\nLabeling our pods is essential because there may be hundreds of pods running in our cluster and we can use labels and selectors to identify the pods.\nIf one of the pods fails, Replica Set will use the configuration under the spec property to re-deploy the pod.\napiVersion: apps/v1 kind: ReplicaSet metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 3 selector: matchLabels: type: front-end kubectl create -f replicaset-definition.yml kubectl get replicaset kubectl delete replicaset myapp-replicaset Scaling the replicaset One of the following commands can be used to scale up the replicaset\nkubectl replace -f replicaset-definition.yml kubectl scale --replicas=6 -f replicaset-definition.yml kubectl scale --replicas=6 replicaset myapp-replicaset Deployments  Deployment provides declarative updates for Pods and RelicaSets When you describe a desired state in a deployment, the deployment controller is capable of changing the actual state to the desired state at a controlled rate. You can define Deployments to create a new ReplicaSets or to remove existing Deployments and adopt all their resources with new Deployments.  Deployments have several interesting use cases which are listed in this page. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\nDeployment lifecycle First the deployment is created.\nDeployment in turn creates the replicaset.\nReplica Set has in turn creates pods.\nKubectl describe deployment command can be used to find more information about the deployment status.\napiVersion: apps/v1 kind: Deployment metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 3 selector: matchLabels: type: front-end kubectl get all Deployment Rollout and Versioning Whenever a new deployment or upgrade an image to the existing deployment, a rollout is triggered. A rollout is the process of gradually deploying or upgrading your application containers.\nWhen a new deployment is created, it triggers a rollout. A new rollout creates a new Deployment revision (Version 1). When the application is upgraded later, a new deployment revision is created (Version 2).\nThis will help us keep track of the changes made to our deployment and enable us to rollback to the previous version of the deployment if necessary.\nkubectl rollout status kubectl rollout history Deployment Strategies The default deployment strategy is Rollout. There is another strategy called Recreate which as the name implies, deletes all the pods and recreates them bringing the entire service down while doing it. Rollout strategy on the other hand, takes down the older version and brings back the newer version one by one. This way, the application never goes down and the upgrade is seamless.\nTo update the image of the running deployment kubectl set image deployment/myapp-deployment nginx-container=nginx:1.12-perl command can be used.\nDeployment Upgrades When a new deployment is created, it creates a ReplicaSet which inturn creates the number of Pods required to meet the number of replicas. When you upgrade your application, the kubernetes deployment creates a NEW replicaset under the hood and starts deploying the containers there. Taking down the pods in old Replica Set also follow the Rolling Update strategy.\nDeployment rollbacks kubectl rollout undo followed by the name of the deployment will allow you to rollback to a previous version. The deployment will destroy the pods in new replicaset and bring back the older ones in the old replicaset.\nkubectl run nginx --image=nginx the kubectl run command actually creates a deployment. A replicaset and pods are automatically created in the backend.\nList of useful commands \u0026gt; kubectl create -f deployment definition.yml \u0026gt; kubectl create -f deployment definition.yml --record \u0026gt; kubectl get deployments \u0026gt; kubectl apply -f deployment definition.yml \u0026gt; kubectl set image deployment/myapp-deployment nginx=nginx:1.9.1 \u0026gt; kubectl rollout status deployment/myapp-deployment \u0026gt; kubectl rollout history deployment/myapp-deployment \u0026gt; kubectl rollout undo deployment/myapp deployment ","description":"Kubernetes controllers","id":10,"section":"notes","tags":null,"title":"Kubernetes controllers","uri":"https://adhithyakrishna.github.io/notes/k8s_for_absolute_beginners/k8s_controllers/"},{"content":"  This notes is for the course Kuberenetes for absolute beginners\nKubernetes service enable communication between various components within or ourside of the application. Kubernetes Services helps us connect applications with other applications or users.\nServices enable connectivity between the group of pods. For example front-end to the users, connection between the frontend and backend processes and backend to to external data source.\nServices enable Loose coupling between microservices in our application.\nNode Port One of the use case of Nodeport is to listen to a port on the Node and forward requests on that port to a port on the pod running the web application.\nThis type of service is know as NodePort service because the service listens to a port on the Node and forwards requests to Pods.\nNodePorts can only be in a valid range which is from 30000 to 32767.\n K8s Services: https://www.udemy.com/course/learn-kubernetes/   Below terms are from the viewpoint of the service. The service is like a virtual server inside of the node. It has its own ip address.\n TargetPort - The port on the Pod where the actual web server is running - (port 80). This is where the service forwards requests to. Port - Port on the service itself. (Simply referred to as the port). NodePort - Port on the node, which can be used to access the web server externally.  apiVersion: v1 kind: Service metadata: name: spring-boot-service namespace: spring-boot spec: selector: app: spring-boot-deployment ports: - port: 8080 targetPort: 8080 nodePort: 30009 type: NodePort Here the only mandatory field is port. The target port would be the same as port if not specified and nodePort value will be between the 30000 and 32767 range (automatically allocated if not specified).\nWe can do multiple port mappings within a single service.\nLabels and selectors are used to map the pods to the service. When a service is created it looks for matching pods with the labels and finds 3 of them. The service then auto selects all 3 pods to forward the external requests coming from the user. No additional configuration is needed to make this happen.\nThis service acts as a built in load balancer to distribute the load across different pods.\n K8s Services: https://www.udemy.com/course/learn-kubernetes/   Kubernetes creates a service that can spans across all the nodes in the cluster and maps the target port to the same nodeport on all the nodes in the cluster, without having to do any additional configurations.\nThis way the application can be accessed using the IP of any node by using the same port number.\nTo summarize â€“ in ANY case whether it be a single pod in a single node, multiple pods on a single node, multiple pods on multiple nodes, the service is created exactly the same without having to do any additional steps during the service creation.\nWhen PODs are removed or added the service is automatically updated making it highly flexible and adaptive. Once created, you wonâ€™t typically have to make any additional configuration changes.\nClusterIP ClusterIP provides a single interface to access pods in a group. A service created for backend pods will help group all the backend pods and provide a single interface for the other pods to access this service, allowing to easily and effectively deploy a microservices based application on a Kubernetes cluster. Similarly, creating additional services for database layer allows the backend pods to access the database layer through this sergice.\nEach service gets an IP and name assigned to it inside the cluster and that is the name that should be used by the other pods to acccess the service. This type of service is known as ClusterIP. ClusterIP is the default type in kubernetes configuration. If we did not specify the type, ClusterIP would be assigned by default.\n K8s Services: https://www.udemy.com/course/learn-kubernetes/   apiVersion: v1 kind: Service metadata: name: back-end spec: type: ClusterIP ports: - targetPort: 80 port: 80 selector: app: myapp type: back-end LoadBalancer Exposes the Service externally using a cloud provider\u0026rsquo;s load balancer.\nOn cloud providers which support external load balancers, setting the type field to LoadBalancer provisions a load balancer for your Service.\napiVersion: v1 kind: Service metadata: name: my-service spec: selector: app.kubernetes.io/name: MyApp ports: - protocol: TCP port: 80 targetPort: 9376 clusterIP: 10.0.171.239 type: LoadBalancer status: loadBalancer: ingress: - ip: 192.0.2.127 Differrence between different services https://stackoverflow.com/questions/41509439/whats-the-difference-between-clusterip-nodeport-and-loadbalancer-service-types\nExcerpts from the above stack overflow link\nYou can access a service from your load balancer\u0026rsquo;s IP address, which routes your request to a nodePort, which in turn routes the request to the clusterIP port. You can acess this service as you would a NodePort or a ClusterIP service as well. A ClusterIP Service is part of a NodePort Service. A NodePort Service is Part of a Load Balancer Service.\nkubectl get services displays the loadbalancer as well as cluster-ip\nminikube service redis-service --url displays the node-ports.\n K8s Services: https://www.udemy.com/course/learn-kubernetes/   ClusterIP - Exposes a service which is only accessible from within the cluster.\nNodePort - Exposes a service via a static port on each nodeâ€™s IP.\nLoadBalancer - Exposes the service via the cloud providerâ€™s load balancer.\nPods within the cluster can talk to each other through clusterIP.\nTo make a pod accessible from outside the cluster, it will create nodePort. Node port will make use of the clusterIP to do this.\nLoad balancer puts a loadbalancer in front so that the inbound traffic is distributed between node ports.\nIf you want to acccess the service from outside a cluster only Nodeport will be accessible and not clusterIP.\nAdditional reference: https://stackoverflow.com/a/72988866\n","description":"Kubernetes services","id":11,"section":"notes","tags":null,"title":"Kubernetes services","uri":"https://adhithyakrishna.github.io/notes/k8s_for_absolute_beginners/k8s_services/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n The emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your siteâ€™s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nðŸ™ˆ ðŸ™ˆ ðŸ™‰ ðŸ™‰ ðŸ™Š ðŸ™Š\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":12,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://adhithyakrishna.github.io/blog/emoji-support/"}]