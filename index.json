[{"uri":"https://adhithyakrishna.github.io/articles/","title":"Articles","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/articles/morris-traversal/","title":"Morris Traversal Algorithm","tags":[],"description":"In this article the morris traversal algorithm is discussed. This algorithm is used for traversing a Binary search tree without any additional memory.","content":"Morris Traversal algorithm To traverse a binary search tree in-order we can either use a stack or recursion. But morris traversal algorithm allows us to traverse the tree without either of these.\nAlgorithm The morris traversal algorithm is easy to implement once we understand the crux of the problem. The pseudocode can be classified into 3 steps\nStep 1 : For a tree, If there is no left children, we know that all the nodes are greater than the current node, so we can start traversing the right tree and start visiting the nodes.\nStep 2 : From the root, we traverse the right most child \u0026lsquo;rc\u0026rsquo; of each left subtree and establish a connection with the current node \u0026lsquo;n\u0026rsquo;. \u0026lsquo;rc\u0026rsquo; is the inorder predecessor for the node \u0026lsquo;n\u0026rsquo;. This connection is represented in the diagram below.\nStep 3 : If the connection is already present, (i.e) the child is already connected to its inorder predecessor, we visit the node and severe the links we established in step 2 and move the current to the right.\nImplementation //Tree structure class TreeNode { int data; TreeNode left; TreeNode right; TreeNode(int data) { this.data = data; } } class MorrisTraversal { public static void morrisTraversal(TreeNode t) { TreeNode current = t; // exit condition, current becomes null only when the entire tree is traversed \twhile (current != null) { if (current.left == null) { // we visit the current node \tSystem.out.println(current.data); current = current.right; } else { // we have nodes on the left that has to be visited  // we keep a copy of the \tTreeNode predecessor = current.left; // we traverse the right subtree of the predecessor until we either reach the \t// end or we reach the current (scenario after the link is established) \twhile (predecessor.right != null \u0026amp;\u0026amp; predecessor.right != current) { predecessor = predecessor.right; } /* * once we break out of the above loop, it should be either 1 of the two * conditons 1) We have reached the end of the the subtree, in this case we * establish connection with the current and move the current to the left for * the next traversal * * 2) (When connection is already established) We have reached the node where we * established the connection between a node and its inorder predecessor, we * severe the ties now, visit the node */ if (predecessor.right == null) { predecessor.right = current; current = current.left; } else { predecessor.right = null; System.out.println(current.data); current = current.right; } } } } public static void main(String args[]) { // line by line code for data insertion code for the ease of understanding \tTreeNode t = new TreeNode(9); t.left = new TreeNode(6); t.right = new TreeNode(12); t.left.left = new TreeNode(3); t.right.left = new TreeNode(10); t.right.right = new TreeNode(14); t.left.left.left = new TreeNode(2); t.left.left.right = new TreeNode(5); t.left.left.left.left = new TreeNode(1); morrisTraversal(t); } } Time complexity: O(N) Space complexity: O(1)\t"},{"uri":"https://adhithyakrishna.github.io/articles/short-palindrome-kmp/","title":"Add characters to make Palindrome KMP","tags":["String","KMP"],"description":"Application of KMP algorithm. This problem focuses on finding shortest palidrome by adding characters to the front of it.","content":" Problem statement Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\nExample 1:\nInput: \u0026ldquo;aacecaaa\u0026rdquo; Output: \u0026ldquo;aaacecaaa\u0026rdquo; Example 2:\nInput: \u0026ldquo;abcd\u0026rdquo; Output: \u0026ldquo;dcbabcd\u0026rdquo;\nSolution This problem utilises a part of the KMP algorithm. You can read more about the algorithm here, KMP algorithm.\nSolving this problem involves a trick, we have to construct the LPS table. This table would help us locate the prefix and suffix in the string, but we are interested in finding out characters that when added to the given string would make it a palindrome.\nTo do that, we add a place holder character before the given String, also append the reversed string infront of the current string. This makes sure that, when we traverse after the random place holder character, the LCS table is constructed with the start pointer pointing to the first character and the end pointer is pointing to the character that is right after the place holder character.\nStep 1 : Create a String in a format of Reverse(String) + \u0026ldquo;#\u0026rdquo; + String\nStep 2 : Construct an LPS table for the given string\nStep 3 : The last index in the table would point out the position until which the original string has a common prefix.\nStep 4 : We construct the final result string by reversing and attaching the substring in front of the original string.\nDiagram illustrates the construction of LCS table public String shortestPalindrome(String s) { String temp = s + \u0026#34;#\u0026#34; + new StringBuilder(s).reverse().toString(); int[] table = calculateLPS(temp); return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s; } public static int[] calculateLPS(String temp) { int[] val = new int[temp.length()]; int start = 0; int end = 1; while (end \u0026lt; temp.length()) { if (temp.charAt(start) == temp.charAt(end)) { val[end] = start + 1; start++; end++; } else { if (start \u0026lt;= 0) { end++; } else { start = val[start - 1]; } } } return val; } Complexity Time complexity: O(n) Space complexity: O(n)\t "},{"uri":"https://adhithyakrishna.github.io/articles/needle-in-haystack-kmp/","title":"Needle in Haystack KMP","tags":["String","KMP"],"description":"Application of KMP algorithm. This problem focuses on finding the substring in the given string","content":" Problem statement Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nInput: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; Output: 2 Example 2:\nInput: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; Output: -1 Clarification:\nReturn 0 when needle is an empty string.\nConstraints:\nhaystack and needle consist only of lowercase English characters.\nSolution Please refer to the KMP article KMP algorithm to learn about the KMP algorithm. The KMP algorithm solves the problem in O(M + N) where M is the length of the large string (haystack) and N is the length of small string (needle)\npublic int needleInHayStack(String haystack, String needle) { if(needle.length() \u0026gt; haystack.length()) { return -1; } if(needle.length() \u0026lt; 0) { return 0; } //construction of LPS table to prevent repetitive iteration \tint[] lpsValues = constructLpsTable(needle); int hIndex = 0; int nIndex = 0; while(hIndex \u0026lt; haystack.length() \u0026amp;\u0026amp; nIndex \u0026lt; needle.length()) { if(haystack.charAt(hIndex) == needle.charAt(nIndex)) { hIndex++; nIndex++; } else { if(nIndex \u0026lt;= 0) { hIndex++; } else { nIndex = lpsValues[nIndex-1]; } } } return nIndex == needle.length() ? hIndex - needle.length() : -1; } public static int[] constructLpsTable(String needle) { int start = 0; int end = 1; int[] lpsTable = new int[needle.length()]; while(end \u0026lt; needle.length()) { if(needle.charAt(end) == needle.charAt(start)) { lpsTable[end] = start + 1; start++; end++; } else{ if(start \u0026lt;= 0) { lpsTable[end] = 0; end++; } else { start = lpsTable[start-1]; } } } return lpsTable; } Sample Input output Input : \u0026#34;hello\u0026#34; , \u0026#34;ll\u0026#34; Output : 2 Input : \u0026#34;world\u0026#34;, \u0026#34;Helloworld\u0026#34; Output : -1 Input : \u0026#34;HelloWorld\u0026#34;, \u0026#34;\u0026#34; Ouput : 1 Time and space complexity Time complexity: O(M + N) Space complexity: O(N)\t"},{"uri":"https://adhithyakrishna.github.io/articles/kmp-pattern-matching/","title":"KMP Pattern Matching Algorithm","tags":["String","Algorithm"],"description":"This article focuses on the awesome KMP pattern matching algorithm to find a substring within a string.","content":" KMP Algorithm I recently came across this awesome algorithm to locate a substring within a string. Let us consider a string s (small string) that has to be located in a large string l. A brute force approach would something like traverse the the larger list l until the start is matched with the small string s, and then use two pointers to traverse both the string. While this may seem like a good approach, consider a scenario where the length of s is 100 characters, 99 characters in the string l matches s but the last character doesn\u0026rsquo;t. In that scenario, we\u0026rsquo;ll have to traverse right from the start again, making the time complexity O(n^2).\nKMP algorithm is useful to solve this issue. But one catch is that we have to precompute the longest proper prefix for which the suffix is same for the small string. so if a list of string is given, this table has to be pre-computed for every unique string that has to be searched.\nStep 1 : Calculating LPS table Step 1 : Initialise the first index to 0.\nStep 2 : Initialise the start pointer to the 0th index and end to the first index.\nStep 3 : Initialise an empty array the same size as the small string.\nStep 4 : The last value in the lps table would be the value for which the prefix and suffix are the same.\nStep 5 : We construct the final string by taking the substring until the largest suffix, reverse it and add it to the given string.\nPlease find the pseudo code below\n/* pseudocode*/ if(char at start == char at end) { The value at index end would be start index + 1 /* This is to indicate that there exist a prefix in the table such that the current element is (or) a part of suffix */ increment i and j } if(char at start != char at end) { //this section has two scenarios \tif(start \u0026lt;= 0) { assign the value of end to 0 increment end to the next value } else { The start index is assigned the value of the start-1 index (ie) we are moving the start index to a point to a value that is different from the current one (essentially, poining to the an index that is before the prefix pair of current element) /* This scenario is illustrated in the diagram below */ } } Diagram illustrates the traversal when start and end are not the same The code for LPS table public static int[] calculateLPS(char[] input) { int start = 0; int end = 1; int[] result = new int[input.length]; while(end \u0026lt; input.length) { if(input[start] == input[end]) { //start index + 1 \tresult[end] = start + 1; start++; end++; } else { if(start \u0026lt;= 0) { result[end] = 0; end++; } else { start = result[start- 1] ; } } } return result; } Complexity Time complexity: O(N) Space complexity: O(N)\tStep 2 : Locate the substring Once the LPS table is calculate, locating the substring is very easy.\nStep 1 : Traverse both the small string and large string together using two pointers.\nStep 2 : if both the characters are equal we increment the two pointers for the next comparison\nStep 2 : If both are not same, the pointer in the index table is moved to an index which lies right before the prefix, if any. ie We are essentially skipping the prefix in the LPS array because, firstly, if a common prefix did exist, we would have traversed it already in large string, if a common prefix did not exist, we\u0026rsquo;ll immediately move to the start of the LPS.\npublic static calculateKMP(char[] large, char[] small) { //calls the above function \tint[] LPSarray = calculateLPS(small); int i = 0; int j = 0; while(i \u0026lt; large.length \u0026amp;\u0026amp; j \u0026lt; small.length) { if(large[i] == small[j]) { i++; j++; } else { if(j \u0026lt;= 0) { //keep traversing the larger text \ti++; } else { j = LPSarray[j-1]; } } } //the smaller string has been traversed all the way \treturn j == small.length; } Input : \u0026#34;helloworld\u0026#34; , \u0026#34;owor\u0026#34; Output : true Input : \u0026#34;helloworld\u0026#34;, \u0026#34;oword\u0026#34; Output : false Time complexity: O(M + N) Space complexity: O(N)\tThere are several intersting problems for which this algorithm can be applied to. Please find the articles below. 1) Needle in a haystack 2) Short palindrome problem  "},{"uri":"https://adhithyakrishna.github.io/articles/threads_concepts/","title":"Threads concepts","tags":["Threads","Concurrency"],"description":"","content":" Concepts 1) Thread creation There are two ways to create threads\n Extending a thread class Implementing a Runnable interface  It is recommended to use runnable interfaces because, class can extend only a single class because of the Java\u0026rsquo;s lack of support to multiple inheritence, but a class can implement multiple interfaces.\n\rThreads can also be created using anonymous classes like below\nThread thread1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;Hello: \u0026#34; + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } }); \rthread1.start() spawns a new thread and invokes the run function and thread.join() waits for the completion of thread execution before it executes the next block of code.\n\r2) Volatile keyword The volatile keyword is used when a value of the variable is modified by different threads. Usage of volatile keyword would make the resource thread safe. Instead of caching the data, java retrieves the value of the variable from the main memory. This can be very useful if you want multiple threads to behave certain way. For example, if you want to stop a thread based on the value of a variable, declaring the variable as a volatile variable would make sure that the threads stop as soon as the variable changes.\n3) Synchronized keyword Synchronized block is to prevent critical section from being accessed by multiple threads at the same time. When two threads access the same resources, there are chances for race condition. race condition is when multiple threads access the same resource at the same time, when one thread races to complete execution before the other. The obvious downside to this is the data inconsistency. To overcome this we can make the critical section (method that utilises the shared resources) Synchronized. This would prevent multiple threads trying to access the same section at the same time and would give access to only a single thread.\nJava provides two synchronization idioms\n Method synchronization Block synchronization  When thread enters into synchronized instance method or block, it acquires Object level lock. If it enters into static synchronized method or block, it acquires class level lock. The lock is released when thread exits the block of code.\n\r4) Synchronization on objects The problem with synchronizing on methods is that, the intrinsic lock is obtained on the object of the class, which means, no other function within the class can be accessed by any other thread until the current thread exits the critical section. To overcome this, we can create java objects and synchronize on them.\nExample to demonstrate synchronizing on object vs methods /* *\tSynchronizing on object */ private Object lock1 = new Object(); public void stageOne() { synchronized (lock1) { // The lock is on the lock1 object \tSystem.out.println(\u0026#34;inside 1\u0026#34;); try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } list1.add(random.nextInt(100)); System.out.println(\u0026#34;leaving 1\u0026#34;); } } /* *\tSynchronizing on method */ public synchronize void stageOne() { System.out.println(\u0026#34;inside 1\u0026#34;); try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } list1.add(random.nextInt(100)); System.out.println(\u0026#34;leaving 1\u0026#34;); } Next Article Thread pools Reference Threading - Cave of programming Part 1  "},{"uri":"https://adhithyakrishna.github.io/articles/ipv4/","title":"Internet protocol version 4 validation","tags":["Online assessment"],"description":"","content":" About the test I recently took an OA. It was a 75 minutes exam consisting of three questions. The test was conducted on codility platform. This OA was different from others in that, we should scan the input from the scanner class and output should be printed using System.out.println() according to the output format provided. While the remaining 2 problems were doable, one problem stood out, it was a simple one line statement.\nProblem statement Validate Ipv4 address\nSolution import java.util.Scanner; public class ValidateIP { public static boolean isIPv4(String IP) { int len = IP.length(); if (len \u0026lt; 7 || len \u0026gt; 15) return false; else if (isIPv4Token(IP)) return true; return false; } private static boolean isIPv4Token(String IP) { int sum = 0, dot = 0, len = IP.length(); char[] cc = IP.toCharArray(); for (int i = 0; i \u0026lt; len; i++) { //scans until the second last element, checks if the previous element was 0 and the next element is not a \u0026#34;.\u0026#34; to ensure its not \u0026#34;00.\u0026#34; \tif (i \u0026lt; len - 1 \u0026amp;\u0026amp; sum == 0 \u0026amp;\u0026amp; cc[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; cc[i + 1] != \u0026#39;.\u0026#39;) { return false; } if (cc[i] == \u0026#39;.\u0026#39;) { dot++; //if \u0026#34;.\u0026#34; is encountered, if should not be in the start as well as in the end, and also the sum calculated should not exceed 255 \tif (i \u0026gt; 0 \u0026amp;\u0026amp; cc[i - 1] == \u0026#39;.\u0026#39; || i == 0 || i == len - 1 || sum \u0026gt; 255) { return false; } //sum is re initialised to 0 \tsum = 0; } else if (cc[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; cc[i] \u0026lt;= \u0026#39;9\u0026#39;) { //sum between two dots are added here \tsum = sum * 10 + cc[i] - \u0026#39;0\u0026#39;; } else return false; } //sum after the last dot should be less than 256 and total number of dots should be one \treturn dot == 3 \u0026amp;\u0026amp; sum \u0026lt; 256; } public static void main(String args[]) { Scanner in = new Scanner(System.in); String val = in.nextLine(); System.out.println(isIPv4(val)); } } Complexity Time complexity: O(N) Space complexity: O(1)\t "},{"uri":"https://adhithyakrishna.github.io/articles/recursion_i/","title":"Recursion I","tags":["Recursion","Learning"],"description":"This article is about recursion, we go over the introduction to recursion and solve common problems asked in the programming interviews using Java","content":" Recursion is bascially a function calling itself. Recursion has to be implemented carefully, otherwise the function might run indefinitely causing the program to crash.\nThere are two important properties to recursion,\n1) Base case - a terminating scenario, which does not use recursion to produce answer.\n2) Recurrence relation - reduces other cases towards the base case.\nThe difficulty of recursion problems solved in this articles are going to be in the increasing order.\nReverse string recursively package com.learning.recursion; public class RecursivePrintString { public static void printReverse(String val) { if (val == null) return; // the second parameter is to keep track of indexes \treverseWords(val, 0); } public static void reverseWords(String val, int index) { // base condition \tif (index \u0026gt;= val.length()) { return; } //recurrance relation \treverseWords(val, index + 1); System.out.println(val.charAt(index)); } public static void main(String args[]) { String val = \u0026#34;helper\u0026#34;; printReverse(val); } } Complexity Time complexity: O(N) Space complexity: O(N)\tReverse character array package com.learning.recursion; public class ReverseString { public static void reverseString(char[] s) { if (s.length == 0) { return; } int[] val = new int[1]; reverseInPairs(s, 0, s.length-1); } //reverses the character array in place \tpublic static void reverseInPairs(char[] s, int left, int right) { if(left \u0026gt;= right) return; char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; reverseInPairs(s, left, right); } public static void main(String args[]) { char[] s = { \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39; }; reverseString(s); for(char ch : s) System.out.println(ch); } } Complexity Time complexity: O(N) Space complexity: O(N)\tSwap nodes in pairs [Linked list] Given a linked list swap the nodes in pairs recursively\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next == null) { return head; } ListNode firstNode = head; ListNode secondNode = head.next; firstNode.next = swapPairs(secondNode.next); secondNode.next = firstNode; return secondNode; } } Complexity Time complexity: O(N) Space complexity: O(N)\tReverse a linked list [Linked list] Given a linked list reverse the linked list recursively\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { return reversing(head, null); } public ListNode reversing(ListNode curr, ListNode prev) { if(curr == null) //we have reached the end \t{ return prev; // prev would be the head of the node \t} //keep a copy of the next node \tListNode next = curr.next; //assign previous value to the current\u0026#39;s next \tcurr.next = prev;\t//recursively call the reversing, note the current for this iteration is the previous value and next copy we took is the current value \treversing(next, curr); } } Complexity Time complexity: O(N) Space complexity: O(N)\tRecursive pascal triangle Find the nth row of the pascal triangle recursively.\nclass Solution { int[][] cache; public List\u0026lt;Integer\u0026gt; getRow(int rowIndex) { //cache is created for the entire matrix  cache = new int[rowIndex+1][]; for(int i=0; i\u0026lt;cache.length; i++) { cache[i] = new int[i+1]; } List\u0026lt;Integer\u0026gt; dataList = new ArrayList\u0026lt;Integer\u0026gt;(rowIndex); for(int i=0; i\u0026lt;rowIndex+1; i++) { dataList.add(recurse(rowIndex, i)); } return dataList; } public int recurse(int row, int col) { if(row == 0 || col == 0 || row == col) { return 1; } if(cache[row][col] == 0) cache[row][col] = recurse(row-1, col-1) + recurse(row - 1, col); return cache[row][col]; } } Complexity Time complexity: O(2^k) Space complexity: O(n^2)\t "},{"uri":"https://adhithyakrishna.github.io/","title":"Dev journal","tags":[],"description":"","content":"\r\r\r\r\rAbout me\r\rHi, I'm Adhithyakrishna, I am a computer science student with an infinite zeal to design and build scalable web applications.\nI previously worked as a software development engineer at Skava, an awesome e-Commerce platform that powers several fortune 500 companies. I am currently pursuing my masters degree in Computer Science at State University of Newyork at Buffalo and my focus area is in software development.\nI started this blog in a quest to find and share the most efficient solution to competitve problems. I have also decided to share programming concepts along the way. All my learnings are going to be consolidated and shared at articles and all my projects are hosted at github.\n\r\rI am actively seeking a fulltime opportunity as a software developer and would be available to start in February 2021. I possess diverse experience as a frontend and backend developer along with solid knowledge of building scalable web applications. I have a strong aptitude for understanding and implementing complex business logic and meeting aggressive goals. If you are hiring or know anyone who is looking for a software developer, please reach out to me at akrishna.cse21@gmail.com or on my Linkedin.\n\r\rEducation and work experience overview\r\r\r\rEducation\r\r\rKumaraguru College of Technology\r\r2012 - 2016\rStudied Bachelor of Engineering in Computer Science\r\rState University of New York at Buffalo \r2019 - 2020\rPursuing Masters of Science in Computer Science\r\r\r\r\r\r\rWork Experience\r\r\rSkava Systems pvt ltd, Coimbatore\r2016 (Jan) - 2019 (June)\rWorked as a Software development engineer.\r\r\r\r\r\r\r\r\rCertifications\r\r\r\rJava - Multithreading\r\r\r\r\r\r\r --\r\r\r\r\r\r"},{"uri":"https://adhithyakrishna.github.io/tags/kmp/","title":"KMP","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/string/","title":"String","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/algorithm/","title":"Algorithm","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/learning/","title":"Learning","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/recursion/","title":"Recursion","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/online-assessment/","title":"Online assessment","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/concurrency/","title":"Concurrency","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/tags/threads/","title":"Threads","tags":[],"description":"","content":""},{"uri":"https://adhithyakrishna.github.io/categories/","title":"Categories","tags":[],"description":"","content":""}]