<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dev journal on Adhithyakrishna</title><link>https://adhithyakrishna.github.io/</link><description>Recent content in Dev journal on Adhithyakrishna</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 14 Sep 2020 19:30:51 -0400</lastBuildDate><atom:link href="https://adhithyakrishna.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Morris Traversal Algorithm</title><link>https://adhithyakrishna.github.io/important-algorithms/morris-traversal/</link><pubDate>Mon, 14 Sep 2020 19:30:51 -0400</pubDate><guid>https://adhithyakrishna.github.io/important-algorithms/morris-traversal/</guid><description>Morris Traversal algorithm To traverse a binary search tree in-order we can either use a stack or recursion. But morris traversal algorithm allows us to traverse the tree without either of these.
Algorithm The morris traversal algorithm is easy to implement once we understand the crux of the problem. The pseudocode can be classified into 3 steps
Step 1 : For a tree, If there is no left children, we know that all the nodes are greater than the current node, so we can start traversing the right tree and start visiting the nodes.</description></item><item><title>Add characters to make Palindrome KMP</title><link>https://adhithyakrishna.github.io/coding-questions/short-palindrome-kmp/</link><pubDate>Sat, 12 Sep 2020 18:24:12 -0400</pubDate><guid>https://adhithyakrishna.github.io/coding-questions/short-palindrome-kmp/</guid><description>Problem statement Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.
Example 1:
Input: &amp;ldquo;aacecaaa&amp;rdquo; Output: &amp;ldquo;aaacecaaa&amp;rdquo; Example 2:
Input: &amp;ldquo;abcd&amp;rdquo; Output: &amp;ldquo;dcbabcd&amp;rdquo;
Solution This problem utilises a part of the KMP algorithm. You can read more about the algorithm here, KMP algorithm.
Solving this problem involves a trick, we have to construct the LPS table.</description></item><item><title>Needle in Haystack KMP</title><link>https://adhithyakrishna.github.io/coding-questions/needle-in-haystack-kmp/</link><pubDate>Sat, 12 Sep 2020 11:55:37 -0400</pubDate><guid>https://adhithyakrishna.github.io/coding-questions/needle-in-haystack-kmp/</guid><description>Problem statement Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo; Output: 2 Example 2:
Input: haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo; Output: -1 Clarification:
Return 0 when needle is an empty string.
Constraints:
haystack and needle consist only of lowercase English characters.
Solution Please refer to the KMP article KMP algorithm to learn about the KMP algorithm.</description></item><item><title>KMP Pattern Matching Algorithm</title><link>https://adhithyakrishna.github.io/important-algorithms/kmp-pattern-matching/</link><pubDate>Sat, 12 Sep 2020 09:24:15 -0400</pubDate><guid>https://adhithyakrishna.github.io/important-algorithms/kmp-pattern-matching/</guid><description>KMP Algorithm I recently came across this awesome algorithm to locate a substring within a string. Let us consider a string s (small string) that has to be located in a large string l. A brute force approach would something like traverse the the larger list l until the start is matched with the small string s, and then use two pointers to traverse both the string. While this may seem like a good approach, consider a scenario where the length of s is 100 characters, 99 characters in the string l matches s but the last character doesn&amp;rsquo;t.</description></item><item><title>Threads concepts</title><link>https://adhithyakrishna.github.io/cs-concepts/threads_concepts/</link><pubDate>Thu, 23 Jul 2020 21:08:54 +0000</pubDate><guid>https://adhithyakrishna.github.io/cs-concepts/threads_concepts/</guid><description>Concepts 1) Thread creation There are two ways to create threads
Extending a thread class Implementing a Runnable interface It is recommended to use runnable interfaces because, class can extend only a single class because of the Java&amp;rsquo;s lack of support to multiple inheritence, but a class can implement multiple interfaces.
Threads can also be created using anonymous classes like below
Thread thread1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &amp;lt; 5; i++) { System.</description></item><item><title>Internet protocol version 4 validation</title><link>https://adhithyakrishna.github.io/coding-questions/ipv4/</link><pubDate>Thu, 13 Aug 2020 05:53:54 -0400</pubDate><guid>https://adhithyakrishna.github.io/coding-questions/ipv4/</guid><description>About the test I recently took an OA. It was a 75 minutes exam consisting of three questions. The test was conducted on codility platform. This OA was different from others in that, we should scan the input from the scanner class and output should be printed using System.out.println() according to the output format provided. While the remaining 2 problems were doable, one problem stood out, it was a simple one line statement.</description></item><item><title>Recursion I</title><link>https://adhithyakrishna.github.io/cs-concepts/recursion_i/</link><pubDate>Thu, 20 Aug 2020 19:37:51 -0400</pubDate><guid>https://adhithyakrishna.github.io/cs-concepts/recursion_i/</guid><description>Recursion is bascially a function calling itself. Recursion has to be implemented carefully, otherwise the function might run indefinitely causing the program to crash.
There are two important properties to recursion,
1) Base case - a terminating scenario, which does not use recursion to produce answer.
2) Recurrence relation - reduces other cases towards the base case.
The difficulty of recursion problems solved in this articles are going to be in the increasing order.</description></item></channel></rss>